<!DOCTYPE html>
<html>
<head>
    <title>Defect Response Time</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Sep 17 2015 17:05:04 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Sep 17 2015 17:05:04 GMT-0700 (PDT)";
        var CHECKSUM = 41270500211;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    readmeUrl: null,
    codeUrl: null,

    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        console.log("_checkChecksum", container);
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },

    _getInformationalHtml: function(){
        var html = '';

        if (this.informationHtml){
            html += this.informationHtml + '<br/><br/>';
        }

        if (this.readmeUrl){
            html += Ext.String.format("For details about the data in this app, please refer to the <a href=\"{0}\" target=\"_blank\">README file</a>.<br/><br/>", this.readmeUrl);
        }

        if (this.codeUrl){
            html += Ext.String.format("Get the code <a href=\"{0}\" target=\"_blank\">here.</a><br/><br/>", this.codeUrl);
        }
        return html;
    },
    beforeRender: function() {
        var me = this,
            informational_html = this._getInformationalHtml();
        this.callParent(arguments);

        if (informational_html && informational_html.length > 0) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: informational_html
            });
        }

        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team."
        });

        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.Color',{
    singleton: true,

    featureCompleteColor: '#8bbc21',
    featureCompleteIncompleteDodColor: '#a6c96a',
    featurePushedColor: '#f28f43',
    featureTotalColor: '#2f7ed8',
    featureDeployedColor: '#8085e9',
    featureNonDeployedColor: '#696969',

    featurePlanned: '#2f7ed8',
    featureAdded:'#8bbc21',
    featureDescoped: '#910000',

    classificationOnTrack: 'green',
    classificationHighRisk: 'red',
    classificationModerateRisk: 'yellow',
    classificationOther: '#f6f6f6',
    classificationNotStarted: '#ffffff',
    classificationCompleted: '#848689',

    storiesAcceptedCount:  '#145499',
    storiesTotalCount: '#f6f6f6',
    storiesCommitted: '#8bbc21',
    storiesNonCommitted: '#f28f43',


    colors: ['#2f7ed8', '#8bbc21', '#910000', '#492970', '#f15c80', '#7cb5ec',
        '#f28f43', '#90ed7d', '#434348', '#8085e9', '#aa1925',
        '#145499','#77a1e5', '#c42525', '#f7a35c', '#a6c96a',
        '#e4d354', '#2b908f', '#f45b5b', '#91e8e1','#1aadce',
        '#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
        '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],

    colorDisplay: [
        '<span style="color:#2f7ed8">',
        '<span style="color:#8bbc21">',
        '<span style="color:#910000">',
        '<span style="color:#492970">',
        '<span style="color:#f15c80">',
        '<span style="color:#f28f43">',
        '<span style="color:#90ed7d">',
        '<span style="color:#434348">',
        '<span style="color:#8085e9">',
        '<span style="color:#aa1925">',
        '<span style="color:#145499">',
        '<span style="color:#77a1e5">',
        '<span style="color:#c42525">',
        '<span style="color:#f7a35c">',
        '<span style="color:#a6c96a">',
        '<span style="color:#e4d354">',
        '<span style="color:#f45b5b">',
        '<span style="color:#91e8e1">',
        '<span style="color:#1aadce">',
        '<span style="color:#4572A7">',
        '<span style="color:#AA4643">',
        '<span style="color:#89A54E">',
        '<span style="color:#80699B">',
        '<span style="color:#3D96AE">',
        '<span style="color:#DB843D">',
        '<span style="color:#92A8CD">',
        '<span style="color:#A47D7C">',
        '<span style="color:#B5CA92">'
    ]


});

Ext.define('Rally.technicalservices.MungingToolbox', {
    singleton: true,
    getPieSeriesData: function(records, pie_field){
        var pie_hash = Rally.technicalservices.MungingToolbox.getCountByField(records, pie_field),
            data = [];

        var keys = _.keys(pie_hash);
        keys = Ext.Array.sort(keys);

        _.each(keys, function(key){
            data.push({
                name: key,
                y: pie_hash[key] || 0
            });
        });
        return data;

    },
    getCountByField: function(records, field){
        var hash = {};

        _.each(records, function(r){
            var val = r.get(field);
            if (val){
                if (hash[val] == undefined){
                    hash[val] = 0;
                }
                hash[val] ++;
            }
        });
        return hash;
    }
});

Ext.define('Rally.technicalservices.DataPopover', {
    alias: 'widget.tsdatapopover',
    extend: 'Rally.ui.dialog.Dialog',

    id: 'grid-popover',
    cls: 'grid-popover',

    maxWidth: 400,
    maxHeight: 300,

    layout: 'fit',

    autoShow: true,
    componentCls: 'rly-popover dark-container',
    header: true,
    preventFocusOnActivate: true,
    shouldHidePopoverOnBodyClick: false,
    shouldHidePopoverOnIframeClick: false,
    autoCenter: false,
    closable: true,
    shadow: false,

    /**
     * @cfg {Ext.Element} target (Required)
     * The default element that the popover should be aligned to when positioned
     */
    target: undefined,

    /**
     * @cfg {String} targetSelector
     * The selector for target to protect in the case of the target being removed from the dom i.e. grid refresh
     */
    targetSelector: undefined,

    /**
     * @cfg {String} targetTriggeredCls
     * The class to add to the target when the popover is being displayed
     */
    targetTriggeredCls: undefined,

    /**
     * @cfg {Ext.Component} owner
     * The Ext component that owns this popover. This is useful for doing .up() component queries or tying data requests to the original component instead of the popover component
     */
    owner: undefined,

    /**
     * @cfg {String|Array|Function} placement
     * How to position the popover -  right | left | top | bottom
     * Can be a string if you only want to allow one position, an array of strings if you want to allow multiple, or a function to determine which ones you want and return the string or array of strings
     * The popover will use this value as a preference choosing the first placeable value first
     */
    placement: undefined,

    /**
     * @cfg Array offsetFromTarget
     * Offset (Object) x and y offset positions of popover when on top, right, bottom and left
     */
    offsetFromTarget: [
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0}
    ],

    /**
     * @cfg Array viewportPadding
     * Offset (Array) amounts from Viewport edge - top | right | bottom | left
     * when specified, the popover will be shifted within the viewport (plus any offset)
     */
    viewportPadding: [0,0,0,0],

    /**
     * @cfg Array targetPosition
     * Position (String) for popover's target when on top, right, bottom and left
     */
    targetPosition: ['b-t','l-r','t-b','r-l'],

    /**
     * @cfg Array chevronPosition
     * Position (String) for popover's chevron when on top, right, bottom and left
     */
    chevronPosition: ['t-b','r-l','b-t','l-r'],

    /**
     * @cfg Array chevronOffset
     * Offset (Object) x and y offset positions of chevron when on top, right, bottom and left
     */
    chevronOffset: [
        {x: 0, y: -14},
        {x: 14, y: 0},
        {x: 0, y: 14},
        {x: -8, y: 0}
    ],

    /**
     * @cfg Boolean showChevron
     * Set to false to not show the chevron when displaying the popover
     */
    showChevron: true,

    constructor: function(config) {
        this.title = config.title || '';
        var filters = [];
        _.each(config.oids, function(oid){
            filters.push({
                property: 'ObjectID',
                value: oid
            });
        });
        filters= Rally.data.wsapi.Filter.or(filters);

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: config.modelName,
            fetch: config.fetch,
            enablePostGet: true,
            filters: filters,
            pageSize: Math.max(config.oids.length, 200),
            limit: config.oids.length
        });
        store.load();

        var items = [{
            xtype: 'rallygrid',
            columnCfgs: config.fetch,
            store: store,
            showPagingToolbar: config.oids.length > 200,
            showRowActionsColumn: false,
            enableBulkEdit: false
        }];

        config.items = Ext.merge(items, config.items);

        this.callParent(arguments);
    }
});

Ext.define('Rally.technicalservices.LookbackToolbox',{
    singleton: true,

    fetchLookbackSnapshotCount: function(find){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.lookback.SnapshotStore',{
            fetch: ['ObjectID'],
            find: find,
            limit: 1,
            pageSize: 1,
            removeUnauthorizedSnapshots: true
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error running lookback query: {0}",  operation.error.errors.join(',')));
                }
            }
        });

        return deferred;
    },
    fetchLookbackRecords: function(find, fetch, hydrate, sort){
        var deferred = Ext.create('Deft.Deferred');

        fetch = fetch || ['ObjectID'];
        hydrate = hydrate || [];
        sort = sort || {_ValidFrom: 1};

        Ext.create('Rally.data.lookback.SnapshotStore',{
            fetch: fetch,
            find: find,
            hydrate: hydrate,
            limit: Infinity,
            sort: sort,
            removeUnauthorizedSnapshots: true
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error running lookback query: {0}",  operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchLookbackFieldTransitions: function(find, field, iso_start_date){

        var previous_values_field = "_PreviousValues." + field;

        find["_ValidFrom"] = {$gte: iso_start_date};
        find[previous_values_field] = {$exists: true};
        find[previous_values_field] = {$ne: null};

        var fetch = ['ObjectID', field, previous_values_field, "_ValidFrom","_SnapshotNumber"];

        return Rally.technicalservices.LookbackToolbox.fetchLookbackRecords(find,fetch);
    },
    fetchLookbackFieldTransitionsCount: function(find, field, iso_start_date){
        var deferred = Ext.create('Deft.Deferred');
        Rally.technicalservices.LookbackToolbox.fetchLookbackFieldTransitions(find, field, iso_start_date).then({
            success: function(snaps){
                var snaps_by_oid = Rally.technicalservices.LookbackToolbox.aggregateSnapsByOidForModel(snaps);
                deferred.resolve(_.keys(snaps_by_oid).length);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred.promise;
    },
    fetchLookbackFieldTransitionIntoCount: function(find, field, iso_start_date, into_value){
        var deferred = Ext.create('Deft.Deferred');

        var previous_values_field = "_PreviousValues." + field;

        find["_ValidFrom"] = {$gte: iso_start_date};
        find[previous_values_field] = {$exists: true};
        if (into_value instanceof Array){
            find[field] = {$in: into_value};
        } else {
            find[field] = into_value;

        }
        var fetch = ['ObjectID', field, previous_values_field, "_ValidFrom","_SnapshotNumber"];

        Rally.technicalservices.LookbackToolbox.fetchLookbackFieldTransitions(find, field, iso_start_date).then({
            success: function(snaps){
                var snaps_by_oid = Rally.technicalservices.LookbackToolbox.aggregateSnapsByOidForModel(snaps);

                //TODO if into_value is an array,  verify that the previous values is not in that array.

                deferred.resolve(_.keys(snaps_by_oid).length);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred.promise;
    },
    fetchLookbackFieldTransitionOutOfCount: function(find, field, iso_start_date, out_of_value){
        var deferred = Ext.create('Deft.Deferred');

        var previous_values_field = "_PreviousValues." + field;

        find["_ValidFrom"] = {$gte: iso_start_date};
        if (out_of_value instanceof Array){
            find[previous_values_field] = {$in: out_of_value};
        } else {
            find[previous_values_field] = out_of_value;
        }


        var fetch = ['ObjectID', field, previous_values_field, "_ValidFrom","_SnapshotNumber"];

        Rally.technicalservices.LookbackToolbox.fetchLookbackFieldTransitions(find, field, iso_start_date).then({
            success: function(snaps){
                var snaps_by_oid = Rally.technicalservices.LookbackToolbox.aggregateSnapsByOidForModel(snaps);
                deferred.resolve(_.keys(snaps_by_oid).length);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred.promise;
    },
    aggregateSnapsByOidForModel: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID || snap.get('ObjectID');
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap.getData());

        });
        return snaps_by_oid;
    },
    aggregateSnapsByOid: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID;
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap);
        });
        return snaps_by_oid;
    }
});


/*
 * create a form field thing.  
 */

Ext.define('Rally.technicalservices.MultiStateComboBox',{
    alias: 'widget.multistatecombo',
    extend: 'Ext.form.FieldContainer',

    mixins: {
        field: 'Ext.form.field.Field'
    },
    
    cls: 'multistate',
    
    config: {
        /**
         * @cfg {String}
         * The label for the field to be passed through to the combobox
         */
        fieldLabel: '',
        
        value: undefined
    },
    initComponent: function() {
        this.callParent(arguments);

        this.mixins.field.initField.call(this);
        
        var me = this;
        this.add([{
            xtype: 'rallycombobox',
            name: 'statefield',
            plugins: ['rallyfieldvalidationui'],
            multiSelect: true,
            emptyText: 'Choose...',
            displayField: 'name',
            valueField: 'value',
            width: this.width,
            editable: false,
            submitValue: false,
            storeType: 'Ext.data.Store',
            storeConfig: {
                remoteFilter: false,
                fields: ['name', 'value'],
                data: []
            },
            listeners: { 
                'change': function(cb,new_value, old_value){
                    me.state_value = new_value;
                }
            }
        }]);
        
        this._loadStates();
    },
    
    _loadStates: function() {
        Rally.technicalservices.WsapiToolbox.fetchAllowedValues("Defect","State").then({
            scope: this,
            success: function(state_names) {
                
                var states = Ext.Array.map(state_names,function(state_name){
                    return { 'name': state_name, 'value': state_name }
                });
                
                var combobox = this.down('rallycombobox');
                combobox.getStore().loadData(states);

                var current_values = this.getValue();
                console.log('current values:', current_values);
                
                if ( !Ext.isArray(current_values) ) {
                    current_values = current_values.split(',');
                }
                combobox.setValue(current_values);
                this.fireEvent('ready',this);
                
            },
            failure: function(msg) { 
                Ext.Msg.alert('Problem Retrieving States', msg);
            }
        });
    },
    
    getSubmitData: function() {
        var data = {};
        data[this.name] = this.state_value;
        return data;
    }
});
Ext.define('Rally.technicalservices.WsapiToolbox',{
    singleton: true,
    fetchWsapiCount: function(model, query_filters){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: ['ObjectID'],
            filters: query_filters,
            limit: 1,
            pageSize: 1
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    
    fetchWsapiRecords: function(model, query_filters, fetch_fields){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
               if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchReleases: function(timebox){

        var deferred = Ext.create('Deft.Deferred'),
            rec = timebox.getRecord(),
            me = this;

        if (rec == null) {
            deferred.resolve([]);
        }

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Release',
            fetch: ['ObjectID'],
            filters: [{
                property: 'Name',
                value: rec.get('Name')
            },{
                property: 'ReleaseStartDate',
                value: rec.get('ReleaseStartDate')
            },{
                property: 'ReleaseDate',
                value: rec.get('ReleaseDate')
            }],
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                 if (success){
                    deferred.resolve(records);
                }   else {
                    deferred.reject("Error loading Releases: " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },
    
    fetchAllowedValues: function(model,field_name) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: model,
            success: function(model) {
                model.getField(field_name).getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        var values = Ext.Array.map(records, function(record) {
                            return record.get('StringValue');
                        });
                        deferred.resolve(values);
                    }
                });
            },
            failure: function(msg) { deferred.reject('Error loading field values: ' + msg); }
        });
        
        return deferred;

    }
});

Ext.define("Rally.TechnicalServices.calculator.DefectResponseTimeCalculator", {
    extend: "Rally.data.lookback.calculator.TimeInStateCalculator",

    config: {
        closedStateNames: ['Fixed','Closed','Junked','Duplicate'],
        productionDefects: [],
        showOnlyProduction: false,
        chartType: 'column', /* column or pie */
        summaryType: 'Summary', // || 'Team'
        projectsByOID: {} // required for 'Team' summaryType
    },
    
    _isCreatedAfterStart: function(snapshot) {
        var me = this;
        
        if ( me.config.showOnlyProduction) {
            var production_defect_oids = Ext.Array.map(this.config.productionDefects,function(d){
                return d.get('ObjectID')
            });
            
            return (
                snapshot.CreationDate >= Rally.util.DateTime.toIsoString(me.config.startDate)
                && Ext.Array.contains(production_defect_oids,snapshot.ObjectID)
            );
        }
        return (snapshot.CreationDate >= Rally.util.DateTime.toIsoString(me.config.startDate));

    },
    
    _isResolved: function(snapshot) {
        var me = this;
        var killed_states = this.config.closedStateNames;

        if ( me.config.showOnlyProduction) {
            var production_defect_oids = Ext.Array.map(this.config.productionDefects,function(d){
                return d.get('ObjectID')
            });
            
            return (
                Ext.Array.contains(killed_states,snapshot.State)
                && Ext.Array.contains(production_defect_oids,snapshot.ObjectID)
                && snapshot.CreationDate >= Rally.util.DateTime.toIsoString(me.config.startDate)
            );
        }

        return ( 
            Ext.Array.contains(killed_states,snapshot.State)
            && snapshot.CreationDate >= Rally.util.DateTime.toIsoString(me.config.startDate) 
        );

    },
    
    runCalculation: function (snapshots) {
        var me = this;
        
        console.log('closed states:', me.closedStateNames, snapshots.length);
        
        this.startDate = this.startDate || this._getStartDate(snapshots);
        this.endDate = this.endDate || this._getEndDate(snapshots);
            
        var final_snaps = Ext.Array.filter(snapshots, function(snapshot){
            return ( me._isResolved(snapshot)  && snapshot._ValidTo == "9999-01-01T00:00:00.000Z" );
        });
        
        var cycle_times_by_project = {};
        var cycle_times = [];
        
        Ext.Array.each(final_snaps,function(snapshot){
            var creation_date_in_js = Rally.util.DateTime.fromIsoString(snapshot.CreationDate);
            var state_date_in_js =    Rally.util.DateTime.fromIsoString(snapshot._ValidFrom);
            var project_oid = snapshot.Project;
            
            if ( ! cycle_times_by_project[project_oid] ) {
                cycle_times_by_project[project_oid] = [];
            }
            
            var time_difference = Rally.util.DateTime.getDifference(state_date_in_js,creation_date_in_js,'hour');
            cycle_times.push(time_difference);
            
            if ( project_oid == 20104652093 ) {
                console.log(snapshot.ObjectID, creation_date_in_js,state_date_in_js,time_difference);
            }
            cycle_times_by_project[project_oid].push(time_difference);
        });

        var series = [];
        var categories = [];
        
        if ( me.summaryType == "Summary" ) { 
            var average = Ext.Array.mean(cycle_times);
            
            if ( me.granularity == "day" ) {
                average = average / 24;
            }
            series = [{name:'Average Response Time',data: [average]}];
            
            if ( me.chartType == "pie" ) {
                series = [{type:'pie', data: [['average',average]] }];
            }
        } else {
            var series_data = [];
            Ext.Object.each(me.projectsByOID, function(project_oid, project_name){
                if ( ! Ext.isEmpty(cycle_times_by_project[project_oid]) ) {
                    var average = Ext.Array.mean(cycle_times_by_project[project_oid]);
                    if ( me.granularity == "day" ) {
                        average = average / 24;
                    }
                    series_data.push(average);
                    categories.push(project_name);
                }
            });
            series = [{name:'Average Resolution Time', data:series_data}];
        }
        
        console.log('series: ', series);
        
        return {
            categories: categories,
            series: series
        }
    }
    
 });
Ext.define('Rally.technicalservices.chart.DefectResponseTime', {
    extend: 'Ext.panel.Panel', 
    alias: 'widget.tsdefectresponsetime',
    logger: new Rally.technicalservices.Logger(),

    config: {
        /**
         * @cfg {Rally.app.TimeboxScope}  (required)
         * The timebox that will provide the beginning and end dates to search creation dates for
         */
        timeboxScope: undefined,
        /**
         * @cfg {Rally.app.Context}  (required)
         * The app context (current project, etc)
         */
        context: undefined,
        
        /**
         * @cfg {Boolean} 
         * Show only production defects (defects associated with an incident)
         */
        showOnlyProduction: false,
        
        /**
         * @cfg [{Boolean}] 
         * State names to include in the definition of 'Closed'
         */
        closedStateNames: ['Closed'],
        /**
         * 
         * @cfg {String}
         * 
         * Whether to show data in Summary view or by Team.  (Team|Summary)
         */
        summaryType: 'Summary'
        
    },
    height: 300,
    border: 0,

    fieldValues: [],
    
    constructor: function(config) {
        this.mergeConfig(config);
        
        this.callParent([this.config]);
        
        if ( Ext.isEmpty(this.timeboxScope) ) {
            throw "(" + this.xtype + ") Missing required attribute: timeboxScope";
        }
        
        if ( this.timeboxScope.type != 'release' ) {
            throw "(" + this.xtype + ") Timebox scope must be of type 'release'";
        }
        
        if ( Ext.isEmpty(this.context) ) {
            throw "(" + this.xtype + ") Missing required attribute: context";
        }
                
    },
    initComponent: function() {
        this.callParent(arguments);
        var me = this;
        
        this.setLoading("Getting valid states...",true);
        Rally.technicalservices.WsapiToolbox.fetchAllowedValues('Defect','State').then({
            scope: this,
            success: function(states){
                this.fieldValues = states;
                this.updateChart();
            },
            failure: function(msg) {
                Ext.Msg.alert("Problem with " + this.xtype, msg);
            }
        });
        
        if ( !Ext.isEmpty(this.timeboxScope.getRecord()) ) {
            this.startDate = this.timeboxScope.getRecord().get('ReleaseStartDate');
            this.endDate = this.timeboxScope.getRecord().get('ReleaseDate');
        }
        
        if (!this.down('#chart_box') ) {
            this.add({
                xtype:'container',
                itemId:'chart_box',
                height: this.height - 10,
                minWidth: 250
            });
        }
        
    },
    
    updateTimebox: function(timebox) {
        this.logger.log('updateTimebox', timebox);
        
        this.timeboxScope = timebox;
        if ( !Ext.isEmpty(this.timeboxScope.getRecord()) ) {
            this.startDate = this.timeboxScope.getRecord().get('ReleaseStartDate');
            this.endDate = this.timeboxScope.getRecord().get('ReleaseDate');
        }
        this.updateChart();
    },
    
    // assumes already have defect states saved
    updateChart: function() {
        var me = this;
        if ( me.down('rallychart') ) { me.down('rallychart').destroy();}

        this.setLoading("Getting defects...");
        Deft.Chain.pipeline([
            this._getDefectsInTimebox,
            this._separateIntoDiscoveryLocations
        ],this).then({
            scope: this,
            success: function(results){
                this._makeChart(results);
            },
            failure: function(msg) {
                Ext.Msg.alert("Problem with " + this.xtype, msg);
            }
        }).always(function() { 
            me.setLoading(false); 
        });
        
    },
    
    /*
     * returns a promise
     */
    _getDefectsInTimebox: function() {
        var model = "Defect";
        var fetch = ['FormattedID','CreationDate','Severity','Tags','c_IncidentCases','State','Project','ObjectID'];
        
        var severity_filters = Rally.data.wsapi.Filter.or([
            { property: 'Severity', value: 'Minor Problem' },
            { property: 'Severity', value: 'Major Problem' },
            { property: 'Severity', value: 'Crash/Data Loss' }
        ]);
        
        var filters = severity_filters;
        
        if ( !Ext.isEmpty(this.timeboxScope.getRecord()) ) {
            this.startDate = this.timeboxScope.getRecord().get('ReleaseStartDate');
            this.endDate = this.timeboxScope.getRecord().get('ReleaseDate');
        
            var date_filters = Rally.data.wsapi.Filter.and([
                { property:'CreationDate', operator: '>=', value: this.startDate },
                { property:'CreationDate', operator: '<=', value: this.endDate }
            ]);
        
            filters = date_filters.and(severity_filters);
        }
        return Rally.technicalservices.WsapiToolbox.fetchWsapiRecords(model, filters, fetch);
    },
    
    _separateIntoDiscoveryLocations: function(records) {
        var locations = { production: [], qa: [] };
        
        Ext.Array.each(records, function(record){
            if (this._hasIncident(record)) {
                locations.production.push(record);
            } else {
                locations.qa.push(record);
            }
        },this);
        
        return locations;
    },
    
    _isCID: function(defect) {
        var tags = Ext.Array.pluck( defect.get('Tags')._tagsNameArray, 'Name' );
        return Ext.Array.contains(tags,'CID');
    },
    
    _hasIncident: function(defect) {
        var cases_link = defect.get('c_IncidentCases');
        return ( !Ext.isEmpty(cases_link.LinkID) );
    },
    
    _makeChart: function(defects_by_location){
        var me = this;
        
        var projects_by_oid = {};
        Ext.Array.each(Ext.Array.push(defects_by_location.qa, defects_by_location.production), function(defect){
            projects_by_oid[defect.get('Project').ObjectID] = defect.get('Project')._refObjectName;
        });
        
        if ( this.down('rallychart') ) { this.down('rallychart').destroy();}
        
        this.down('#chart_box').removeAll();
        this.down('#chart_box').setLoading('Preparing Chart');
        
        this.logger.log('creating chart for start/end:', this.startDate, this.endDate);
        
        var colors = ['#fff'];
        this.chartType = 'pie';
        if ( me.summaryType != 'Summary' ) {
            this.chartType = 'column';
            colors = ['blue'];
        }
        
        var chart = this.down('#chart_box').add({
            xtype:'rallychart',
            height: this.height - 15,
            loadMask: false,
            storeType: 'Rally.data.lookback.SnapshotStore',
            storeConfig: {
                find: {
                    CreationDate: {
                        '$gte': Rally.util.DateTime.toIsoString(this.startDate),
                        '$lte': Rally.util.DateTime.toIsoString(this.endDate)
                    },
                    _TypeHierarchy: 'Defect',
                    _ProjectHierarchy: this.context.getProject().ObjectID
                },
                compress: true,
                fetch: ['State','CreationDate'],
                hydrate: ['State']
            },
            calculatorType: 'Rally.TechnicalServices.calculator.DefectResponseTimeCalculator',
            calculatorConfig: {
                trackLastValueForTheseFields: ['_ValidTo', '_ValidFrom', 'State'],
                productionDefects: defects_by_location.production,
                showOnlyProduction: me.showOnlyProduction,
                closedStateNames: me.closedStateNames,
                startDate: me.startDate,
                endDate: me.endDate,
                granularity: 'day',
                projectsByOID: projects_by_oid,
                summaryType: me.summaryType,
                chartType: me.chartType
            },
            sort: {
                "_ValidFrom": 1
            },
            chartConfig: this._getChartConfig(me.summaryType),
            chartColors: colors
        });
        
        chart.on('chartRendered', function() { 
                this.down('#chart_box').setLoading(false);
            }, this);
    },
    
    _getChartConfig: function(summary_type) {
        if ( summary_type == "Summary" ) {
            return this._getSummaryChartConfig();
        } 
        return this._getTeamChartConfig();
    },
    
    _getSummaryChartConfig: function() {
        return  {
            chart: {
                type: 'pie'
            },
            title: {
                text: null
            },
            xAxis: {
                labels: { 
                    enabled: false
                }
            },
            legend: { 
                enabled: false
            },
            tooltip: {
                enabled: false
            },
            yAxis: {
                title: { 
                    text: null
                },
                min: 0
            },
            plotOptions: {
                'pie': {
                    colors: ['#fff'],
                    allowPointSelect: false,
                    dataLabels: {
                        distance: -100,
                        enabled: true,
                        style: {
                            color: 'gray',
                            fontSize: '25px'
                        },
                        formatter: function() {
                            return Ext.util.Format.number(this.y,'0.0') + " Days";
                        }
                    }
                },
                'column': {
                    marker: { enabled: false }
                }
            }
        };
    },
    
    _getTeamChartConfig: function() {
        return  {
            
            chart: {
                type: 'bar'
            },
            title: {
                text: null
            },
            tooltip: {
                formatter: function(){
                    return Ext.String.format('{0}<br/>{1}: <b>{2}</b>',this.x, this.series.name, Ext.util.Format.number(this.point.y,'0.0'));
                }
            },
            xAxis: {
                type: 'category',
                labels: {
                    formatter: function(){
                        return Ext.String.format('<span title="{0}">{1}</span>',this.value, Ext.util.Format.ellipsis(this.value, 15));
                    }
                }
            },
            yAxis: {
                title: { text: 'Days'}
            },
            plotOptions: {
                bar: {
                    dataLabels: {
                        enabled: false
                    }
                }
            },
            legend: {
                enabled: false
            }
        };
    }
});

Ext.define("TSDefectResponseTime", {
    extend: 'Rally.app.TimeboxScopedApp',
    scopeType: 'release',
    supportsUnscheduled: false,
    
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    config: {
        defaultSettings: {
            showOnlyProduction:  true,
            closedStateNames: ['Fixed']
        }
    },

    summaryType: 'Team',

    layout: { type:'vbox'},
    
    timeboxScope: null,

    onScopeChange: function(timeboxScope){
        
        this.timeboxScope = timeboxScope;
        
        if (!this.down('rallybutton')){
            var container = this.add({xtype:'container', layout: { type:'hbox'}, width: this.getWidth() - 25 });
            
            container.add({
                xtype: 'rallybutton',
                text: '< Back to Summary',
                cls: 'secondary rly-small',
                listeners: {
                    scope: this,
                    click: this._updateView
                }
            });
            
            container.add({xtype:'container', flex: 1});
            
            container.add({xtype:'container', itemId: 'state_box', tpl:"<tpl>Resolved States: {closedStates}</tpl>" });
        }
        
        if (this.down('tsdefectresponsetime')){
            this.down('tsdefectresponsetime').updateTimebox(this.timeboxScope);
        } else {
            this._createChart();
        }

    },
    
    // expect type to be 'Summary' or 'Team'
    _createChart: function() {
        if (this.down('tsdefectresponsetime')){
            this.down('tsdefectresponsetime').destroy();
        }
        
        if ( !Ext.isArray(this.getSetting('closedStateNames') ) ) {
            var settings = this.getSettings();
            settings.closedStateNames = this.getSetting('closedStateNames').split(',');
            this.setSettings(settings);
        }

        this.down('#state_box').update({closedStates: this.getSetting('closedStateNames').join(',')});

        
        this.add({
            xtype: 'tsdefectresponsetime',
            timeboxScope: this.timeboxScope,
            context: this.getContext(),
            closedStateNames: this.getSetting('closedStateNames'),
            showOnlyProduction: this.getSetting('showOnlyProduction'),
            summaryType: this.summaryType,
            width: this.getWidth() - 25
        });
    },
    
    getSettingsFields: function() {
        return [
            {
                name: 'showOnlyProduction',
                xtype: 'rallycheckboxfield',
                boxLabelAlign: 'after',
                fieldLabel: '',
                margin: '0 0 25 20',
                boxLabel: 'Show Production Only<br/><span style="color:#999999;"><i>Tick to show only defects associated with an incident</i></span>'
            },
            {
                name: 'closedStateNames',
                xtype: 'multistatecombo',
                labelWidth: 100,
                width: 500,
                margin: '0 0 25 10',
                fieldLabel: 'Resolved States',
                readyEvent: 'ready'
            }
        ];
    },
    
    _updateView: function(btn){
        if (btn.text == 'Team View'){
            btn.setText("< Back to Summary");
            this.summaryType = 'Team';
            this._createChart();
        } else {
            btn.setText("Team View");
            this.summaryType = 'Summary';
            this._createChart();
        }
    },
    
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{
            readmeUrl: "https://github.com/RallyTechServices/scrum-team-metrics/blob/master/defect-response-time/README.md",
            codeUrl: "https://github.com/RallyTechServices/scrum-team-metrics/tree/master/defect-response-time"
        });
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        Ext.apply(this, settings);
        this._createChart();
    }
});

            
               Rally.launchApp('TSDefectResponseTime', {
                   name: 'Defect Response Time'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.circle_value {
    font-size: 250%;
    color: white;
}

.circle_label {
    color: white;
}
    </style>

</head>
<body></body>
</html>