<!DOCTYPE html>
<html>
<head>
    <title>Feature Summary</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Aug 27 2015 14:20:01 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Aug 27 2015 14:20:01 GMT-0700 (PDT)";
        var CHECKSUM = 39816727793;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350, 
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        console.log("_checkChecksum", container);
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if (! app.isExternal() ) {
                
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            html:"This app was created by the Rally Technical Services Team.  <br/><br/>For details about the data in this app, please refer to the <a href=\"https://github.com/RallyTechServices/scrum-team-metrics/blob/master/README.md\" target=\"_blank\">README file</a>."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.Color',{
    singleton: true,

    featureCompleteColor: '#8bbc21',
    featureCompleteIncompleteDodColor: '#a6c96a',
    featurePushedColor: '#f28f43',
    featureTotalColor: '#2f7ed8',
    featureDeployedColor: '#8085e9',
    featureNonDeployedColor: '#696969',

    featurePlanned: '#2f7ed8',
    featureAdded:'#8bbc21',
    featureDescoped: '#910000',

    classificationOnTrack: 'green',
    classificationHighRisk: 'red',
    classificationModerateRisk: 'yellow',
    classificationOther: '#f6f6f6',

    storiesAcceptedCount:  '#145499',
    storiesTotalCount: '#f6f6f6',


    colors: ['#2f7ed8', '#8bbc21', '#910000', '#492970', '#f15c80', '#7cb5ec',
        '#f28f43', '#90ed7d', '#434348', '#8085e9', '#aa1925',
        '#145499','#77a1e5', '#c42525', '#f7a35c', '#a6c96a',
        '#e4d354', '#2b908f', '#f45b5b', '#91e8e1','#1aadce',
        '#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
        '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],

    colorDisplay: [
        '<span style="color:#2f7ed8">',
        '<span style="color:#8bbc21">',
        '<span style="color:#910000">',
        '<span style="color:#492970">',
        '<span style="color:#f15c80">',
        '<span style="color:#f28f43">',
        '<span style="color:#90ed7d">',
        '<span style="color:#434348">',
        '<span style="color:#8085e9">',
        '<span style="color:#aa1925">',
        '<span style="color:#145499">',
        '<span style="color:#77a1e5">',
        '<span style="color:#c42525">',
        '<span style="color:#f7a35c">',
        '<span style="color:#a6c96a">',
        '<span style="color:#e4d354">',
        '<span style="color:#f45b5b">',
        '<span style="color:#91e8e1">',
        '<span style="color:#1aadce">',
        '<span style="color:#4572A7">',
        '<span style="color:#AA4643">',
        '<span style="color:#89A54E">',
        '<span style="color:#80699B">',
        '<span style="color:#3D96AE">',
        '<span style="color:#DB843D">',
        '<span style="color:#92A8CD">',
        '<span style="color:#A47D7C">',
        '<span style="color:#B5CA92">'
    ]


});

Ext.define('Rally.technicalservices.DataPopover', {
    alias: 'widget.tsdatapopover',
    extend: 'Rally.ui.dialog.Dialog',

    id: 'grid-popover',
    cls: 'grid-popover',

    maxWidth: 400,
    maxHeight: 300,

    layout: 'fit',

    autoShow: true,
    componentCls: 'rly-popover dark-container',
    header: true,
    preventFocusOnActivate: true,
    shouldHidePopoverOnBodyClick: false,
    shouldHidePopoverOnIframeClick: false,
    autoCenter: false,
    closable: true,
    shadow: false,

    /**
     * @cfg {Ext.Element} target (Required)
     * The default element that the popover should be aligned to when positioned
     */
    target: undefined,

    /**
     * @cfg {String} targetSelector
     * The selector for target to protect in the case of the target being removed from the dom i.e. grid refresh
     */
    targetSelector: undefined,

    /**
     * @cfg {String} targetTriggeredCls
     * The class to add to the target when the popover is being displayed
     */
    targetTriggeredCls: undefined,

    /**
     * @cfg {Ext.Component} owner
     * The Ext component that owns this popover. This is useful for doing .up() component queries or tying data requests to the original component instead of the popover component
     */
    owner: undefined,

    /**
     * @cfg {String|Array|Function} placement
     * How to position the popover -  right | left | top | bottom
     * Can be a string if you only want to allow one position, an array of strings if you want to allow multiple, or a function to determine which ones you want and return the string or array of strings
     * The popover will use this value as a preference choosing the first placeable value first
     */
    placement: undefined,

    /**
     * @cfg Array offsetFromTarget
     * Offset (Object) x and y offset positions of popover when on top, right, bottom and left
     */
    offsetFromTarget: [
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0},
        {x: 0, y: 0}
    ],

    /**
     * @cfg Array viewportPadding
     * Offset (Array) amounts from Viewport edge - top | right | bottom | left
     * when specified, the popover will be shifted within the viewport (plus any offset)
     */
    viewportPadding: [0,0,0,0],

    /**
     * @cfg Array targetPosition
     * Position (String) for popover's target when on top, right, bottom and left
     */
    targetPosition: ['b-t','l-r','t-b','r-l'],

    /**
     * @cfg Array chevronPosition
     * Position (String) for popover's chevron when on top, right, bottom and left
     */
    chevronPosition: ['t-b','r-l','b-t','l-r'],

    /**
     * @cfg Array chevronOffset
     * Offset (Object) x and y offset positions of chevron when on top, right, bottom and left
     */
    chevronOffset: [
        {x: 0, y: -14},
        {x: 14, y: 0},
        {x: 0, y: 14},
        {x: -8, y: 0}
    ],

    /**
     * @cfg Boolean showChevron
     * Set to false to not show the chevron when displaying the popover
     */
    showChevron: true,

    constructor: function(config) {
        this.title = config.title || '';
        var filters = [];
        _.each(config.oids, function(oid){
            filters.push({
                property: 'ObjectID',
                value: oid
            });
        });
        filters= Rally.data.wsapi.Filter.or(filters);

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: config.modelName,
            fetch: config.fetch,
            enablePostGet: true,
            filters: filters,
            pageSize: Math.max(config.oids.length, 200),
            limit: config.oids.length
        });
        store.load();

        var items = [{
            xtype: 'rallygrid',
            columnCfgs: config.fetch,
            store: store,
            showPagingToolbar: config.oids.length > 200,
            showRowActionsColumn: false,
            enableBulkEdit: false
        }];

        config.items = Ext.merge(items, config.items);

        this.callParent(arguments);
    }
});

Ext.define('Rally.technicalservices.LookbackToolbox',{
    singleton: true,

    fetchLookbackSnapshotCount: function(find){
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.lookback.SnapshotStore',{
            fetch: ['ObjectID'],
            find: find,
            limit: 1,
            pageSize: 1,
            removeUnauthorizedSnapshots: true
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error running lookback query: {0}",  operation.error.errors.join(',')));
                }
            }
        });

        return deferred;
    },
    fetchLookbackRecords: function(find, fetch, hydrate, sort){
        var deferred = Ext.create('Deft.Deferred');

        fetch = fetch || ['ObjectID'];
        hydrate = hydrate || [];
        sort = sort || {_ValidFrom: 1};

        Ext.create('Rally.data.lookback.SnapshotStore',{
            fetch: fetch,
            find: find,
            hydrate: hydrate,
            limit: Infinity,
            sort: sort,
            removeUnauthorizedSnapshots: true
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error running lookback query: {0}",  operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchLookbackFieldTransitions: function(find, field, iso_start_date){

        var previous_values_field = "_PreviousValues." + field;

        find["_ValidFrom"] = {$gte: iso_start_date};
        find[previous_values_field] = {$exists: true};
        find[previous_values_field] = {$ne: null};

        var fetch = ['ObjectID', field, previous_values_field, "_ValidFrom","_SnapshotNumber"];

        return Rally.technicalservices.LookbackToolbox.fetchLookbackRecords(find,fetch);
    },
    fetchLookbackFieldTransitionsCount: function(find, field, iso_start_date){
        var deferred = Ext.create('Deft.Deferred');
        Rally.technicalservices.LookbackToolbox.fetchLookbackFieldTransitions(find, field, iso_start_date).then({
            success: function(snaps){
                var snaps_by_oid = Rally.technicalservices.LookbackToolbox.aggregateSnapsByOidForModel(snaps);
                deferred.resolve(_.keys(snaps_by_oid).length);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred.promise;
    },
    fetchLookbackFieldTransitionIntoCount: function(find, field, iso_start_date, into_value){
        var deferred = Ext.create('Deft.Deferred');

        var previous_values_field = "_PreviousValues." + field;

        find["_ValidFrom"] = {$gte: iso_start_date};
        find[previous_values_field] = {$exists: true};
        if (into_value instanceof Array){
            find[field] = {$in: into_value};
        } else {
            find[field] = into_value;

        }
        var fetch = ['ObjectID', field, previous_values_field, "_ValidFrom","_SnapshotNumber"];

        Rally.technicalservices.LookbackToolbox.fetchLookbackFieldTransitions(find, field, iso_start_date).then({
            success: function(snaps){
                var snaps_by_oid = Rally.technicalservices.LookbackToolbox.aggregateSnapsByOidForModel(snaps);

                //TODO if into_value is an array,  verify that the previous values is not in that array.

                deferred.resolve(_.keys(snaps_by_oid).length);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred.promise;
    },
    fetchLookbackFieldTransitionOutOfCount: function(find, field, iso_start_date, out_of_value){
        var deferred = Ext.create('Deft.Deferred');

        var previous_values_field = "_PreviousValues." + field;

        find["_ValidFrom"] = {$gte: iso_start_date};
        if (out_of_value instanceof Array){
            find[previous_values_field] = {$in: out_of_value};
        } else {
            find[previous_values_field] = out_of_value;
        }


        var fetch = ['ObjectID', field, previous_values_field, "_ValidFrom","_SnapshotNumber"];

        Rally.technicalservices.LookbackToolbox.fetchLookbackFieldTransitions(find, field, iso_start_date).then({
            success: function(snaps){
                var snaps_by_oid = Rally.technicalservices.LookbackToolbox.aggregateSnapsByOidForModel(snaps);
                deferred.resolve(_.keys(snaps_by_oid).length);
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred.promise;
    },
    aggregateSnapsByOidForModel: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID || snap.get('ObjectID');
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap.getData());

        });
        return snaps_by_oid;
    },
    aggregateSnapsByOid: function(snaps){
        //Return a hash of objects (key=ObjectID) with all snapshots for the object
        var snaps_by_oid = {};
        Ext.each(snaps, function(snap){
            var oid = snap.ObjectID;
            if (snaps_by_oid[oid] == undefined){
                snaps_by_oid[oid] = [];
            }
            snaps_by_oid[oid].push(snap);
        });
        return snaps_by_oid;
    }
});


Ext.define('Rally.technicalservices.WsapiToolbox',{
    singleton: true,
    fetchWsapiCount: function(model, query_filters){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: ['ObjectID'],
            filters: query_filters,
            limit: 1,
            pageSize: 1
        }).load({
            callback: function(records, operation, success){
                if (success){
                    deferred.resolve(operation.resultSet.totalRecords);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} count for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchWsapiRecords: function(model, query_filters, fetch_fields){
        var deferred = Ext.create('Deft.Deferred');

        var store = Ext.create('Rally.data.wsapi.Store',{
            model: model,
            fetch: fetch_fields,
            filters: query_filters,
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
               if (success){
                    deferred.resolve(records);
                } else {
                    deferred.reject(Ext.String.format("Error getting {0} for {1}: {2}", model, query_filters.toString(), operation.error.errors.join(',')));
                }
            }
        });
        return deferred;
    },
    fetchReleases: function(timebox){

        var deferred = Ext.create('Deft.Deferred'),
            rec = timebox.getRecord(),
            me = this;

        if (rec == null) {
            deferred.resolve([]);
        }

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Release',
            fetch: ['ObjectID'],
            filters: [{
                property: 'Name',
                value: rec.get('Name')
            },{
                property: 'ReleaseStartDate',
                value: rec.get('ReleaseStartDate')
            },{
                property: 'ReleaseDate',
                value: rec.get('ReleaseDate')
            }],
            limit: Infinity
        }).load({
            callback: function(records, operation, success){
                 if (success){
                    deferred.resolve(records);
                }   else {
                    deferred.reject("Error loading Releases: " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },
    
    _fetchAllowedValues: function(model,field_name) {
        var deferred = Ext.create('Deft.Deferred');

        Rally.data.ModelFactory.getModel({
            type: model,
            success: function(model) {
                model.getField(field_name).getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        var values = Ext.Array.map(records, function(record) {
                            return record.get('StringValue');
                        });
                        deferred.resolve(values);
                    }
                });
            },
            failure: function(msg) { deferred.reject('Error loading field values: ' + msg); }
        });
        
        return deferred;

    }
});

Ext.define('Rally.technicalservices.chart.FeatureSummaryByTeam', {
    extend: 'Rally.ui.chart.Chart',
    alias: 'widget.tsfeaturesummarybyteam',

    config: {

        loadMask: false,

        chartConfig: {
            colors: [
                Rally.technicalservices.Color.featurePlanned,
                Rally.technicalservices.Color.featureAdded,
                Rally.technicalservices.Color.featureDescoped,
                Rally.technicalservices.Color.featureNonDeployedColor
            ],

            chart: {
                zoomType: 'xy'
            },
            title: {
                text: null
            },
            xAxis: {
                type: 'category',
                labels: {
                    //rotation: -60,
                    style: {
                        fontSize: '11px',
                        fontFamily: 'Verdana, sans-serif'
                    },
                    useHTML: true,
                    formatter: function(){
                        return '<span title="' + this.value + '"> ' + Ext.util.Format.ellipsis(this.value, 15) + '</span>';
                    }
                }
            },
            yAxis: {
                title: {
                    text: 'Feature Count'
                }
            },
            plotOptions: {
                series: {
                    borderWidth: 0,
                    stacking: "normal"
                }
            },
            tooltip: {
                formatter: function () {
                    var total = 0,
                        x = this.point.x,
                        descoped = 0,
                        y = this.y;

                    _.each(this.series.chart.series, function(s){
                         if (s.name == "Descoped"){
                            descoped = s.yData[x];
                        } else {
                            total += s.yData[x];
                        }
                    });

                    if (this.series.name == "Descoped"){
                        y = -descoped;
                    }

                    if (this.series.name == "Planned"){
                        y = y - descoped;
                    }

                    return this.x + '<br/>' + this.series.name + ': ' + y + '<br/>' +
                        'Total: ' + total;
                }
            },
            legend: {
                layout: 'vertical',
                align: 'right',
                verticalAlign: 'bottom',
                floating: true,
                y: -30
            }
        },
        chartData: {
            series: []
        }

    },
    constructor: function(config) {
        this.mergeConfig(config);

        this.chartData.series = this._getSeries(config.featureSummaryCalculator);
        this.callParent([this.config]);

    },
    _getSeries: function(calculator){

        var categories = this._getCategories(calculator);

        var start_records = calculator.startRecords,
            end_records = calculator.endRecords,
            added_oids = calculator.featuresAdded,
            descoped_oids = calculator.featuresDescoped,
            planned_oids = calculator.featuresOnDay0,
            completed_states = calculator.completedStates,
            proj_hash = {};
        console.log('---',descoped_oids, planned_oids,completed_states);

        _.each(start_records, function(r){
            var proj = r.get('Project').Name,
                oid = r.get('ObjectID');

            if (!proj_hash[proj]){
                proj_hash[proj] = {planned: 0, added: 0, descoped: 0, done: 0}
            }
            if (Ext.Array.contains(planned_oids, oid)){
                proj_hash[proj].planned++;
            }
            if (Ext.Array.contains(descoped_oids, oid)){
                proj_hash[proj].descoped++;
            }
        });

        _.each(end_records, function(r){
            var proj = r.get('Project').Name,
                oid = r.get('ObjectID');

            if (!proj_hash[proj]){
                proj_hash[proj] = {planned: 0, added: 0, descoped: 0, done: 0}
            }
            if (Ext.Array.contains(added_oids,oid)){
                proj_hash[proj].added++;
            }
            if (Ext.Array.contains(completed_states, r.get('State'))){
                proj_hash[proj].done++;
            }
        });

        console.log('---',proj_hash);

        this.chartData.categories = categories;

        var planned_data = [],
            descoped_data = [],
            added_data = [],
            done_data = [];

        _.each(categories, function(proj){
            var proj_obj = proj_hash[proj] || {},
                descoped = proj_hash[proj].descoped || 0;

            planned_data.push(proj_obj.planned || 0 - descoped);
            descoped_data.push(-descoped);
            added_data.push(proj_obj.added || 0);
            done_data.push(proj_obj.done || 0);
        });

        console.log('---',categories, planned_data, descoped_data,added_data, done_data);
        var series =  [{
            name: 'Added',
            type: 'bar',
            data: added_data,
           // stack: 'total'
        },{
            name: 'Planned',
            type: 'bar',
            data: planned_data,
            //  stack: 'total'
        },{
            name: 'Descoped',
            type: 'bar',
            data: descoped_data
        //},{
        //    name: 'Done',
        //    type: 'spline',
        //    data: done_data
        }];

        return series;
    },
    _getCategories: function(calculator){
        var categories = Ext.Array.merge(this._getTeamArray(calculator.startRecords), this._getTeamArray(calculator.endRecords));
        return Ext.Array.sort(categories);
    },
    _getTeamArray: function(records){
        var teams = [];
        _.each(records, function(r){
            var team = r.get('Project').Name;
            if (!Ext.Array.contains(teams,team)){
                teams.push(team);
            }
        });
        return teams;
    },
    _setChartColorsOnSeries: function () {
        return null;
    }
});



Ext.define('Rally.technicalservices.calculator.FeatureSummary',{
    config: {
        completedStates: ["Operate","Done"],
        plannedDate: undefined,
        timeboxScope: undefined,
        featureModelName: "PortfolioItem/Feature",
        releases: undefined
    },
    notCalculated: 0,

    /**
     * Features associated with the current Release that are currently in the completedState
     */
    featuresCompleted: undefined,
    totalFeatures: undefined,
    plannedFeatures: undefined,
    newFeaturesInRelease: undefined,
    descopedFeatures: undefined,
    doneFeaturesWithIncompleteDod: undefined,

    constructor: function (config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },
    _getStartFind: function(release_oids){
        var release_start_date = Rally.util.DateTime.toIsoString(this.timeboxScope.getRecord().get('ReleaseStartDate'));

        return {
            _TypeHierarchy: this.featureModelName,
            _ProjectHierarchy: this.context.getProject().ObjectID,
            __At: release_start_date,
            Release: {$in: release_oids}
        };
    },
    _getEndFind: function(release_oids){
        var release_end_date = Rally.util.DateTime.toIsoString(this.timeboxScope.getRecord().get('ReleaseDate'));
        if (release_end_date > new Date()){
            release_end_date = "current";
        }
        return {
            _TypeHierarchy: this.featureModelName,
            _ProjectHierarchy: this.context.getProject().ObjectID,
            __At: release_end_date,
            Release: {$in: release_oids}
        };
    },
    calculate: function(){
        var deferred = Ext.create('Deft.Deferred'),
            release_oids = _.map(this.releases, function(r){return r.get('ObjectID')}),
            fetch = ['ObjectID','c_FeatureDeploymentType','State','Project'];

        var promises = [
            Rally.technicalservices.LookbackToolbox.fetchLookbackRecords(this._getStartFind(release_oids), fetch,['Project']),
            Rally.technicalservices.LookbackToolbox.fetchLookbackRecords(this._getEndFind(release_oids), fetch,['State','Project']),
            this.getDoneItemsWithIncompleteDoD()
        ];

        Deft.Promise.all(promises).then({
            scope: this,
            success: function(results){
                this.startRecords = results[0];
                this.endRecords = results[1];

                this.featuresOnDay0 = _.map(results[0], function(r){ return r.get('ObjectID')}),
                this.featuresCurrentOrOnLastDayOfRelease = _.map(results[1], function(r){return r.get('ObjectID')}),
                this.featuresDescoped = Ext.Array.difference(this.featuresOnDay0, this.featuresCurrentOrOnLastDayOfRelease),
                this.featuresAdded = Ext.Array.difference(this.featuresCurrentOrOnLastDayOfRelease, this.featuresOnDay0);
                this.featuresCompleted = this._getCompletedFeatureOids(results[1]);
                this.doneFeaturesWithIncompleteDoD = this._getFeatureWithIncompleteDoDCount(results[2]);
                this._setDeployableFeatures(results[0],results[1]);
                deferred.resolve();
            },
            failure: function(msg){
                deferred.reject(msg);
            }
        });
        return deferred;
    },
    _getCompletedFeatureOids: function(records){
        var completed_records = [],
            completed_states = this.completedStates;

        _.each(records, function(r){
            var state = r.get('State') || null;
            if (Ext.Array.contains(completed_states, state)){
                completed_records.push(r.get('ObjectID'));
            }
        }, this);
        return completed_records;
    },
    _setDeployableFeatures: function(day0Features, currentFeatures){
        var non_deployable = [],
            deployable = [];


         _.each(currentFeatures, function(f){
            var deployment_type = f.get('c_FeatureDeploymentType');
            if (deployment_type && /^N\/A/.test(deployment_type)){
                non_deployable.push(f.get('ObjectID'));
            } else {
                deployable.push(f.get('ObjectID'));
            }
        });

        _.each(day0Features, function(f){
            var deployment_type = f.get('c_FeatureDeploymentType'),
                oid = f.get('ObjectID');
            if (!Ext.Array.contains(deployable, oid) &&
                    !Ext.Array.contains(non_deployable, oid)){

                if (/^N\/A/.test(deployment_type)){
                    non_deployable.push(oid);
                } else {
                    deployable.push(oid);
                }
            }
        });

        this.deployableFeatures = deployable;
        this.nonDeployableFeatures = non_deployable;

    },
    getDoneItemsWithIncompleteDoD: function(){
        var filters = this.timeboxScope.getQueryFilter();

        filters = filters.and(Ext.create('Rally.data.wsapi.Filter',{
            property: 'c_DoDStoryType',
            operator: '!=',
            value: ''
        }));

        filters = filters.and(Ext.create('Rally.data.wsapi.Filter',{
            property: 'ScheduleState',
            operator: '!=',
            value: "Accepted"
        }));

        var state_filters = [];
        _.each(this.completedStates, function(state){
            state_filters.push({
                property: 'Feature.State.Name',
                value: state
            });
        });
        filters = filters.and(Rally.data.wsapi.Filter.or(state_filters));

        //TODO - process the data to return the number of features
        return Rally.technicalservices.WsapiToolbox.fetchWsapiRecords('HierarchicalRequirement',filters,['Feature','ObjectID']);
    },
    _getFeatureWithIncompleteDoDCount: function(records){
        var features = [];
        _.each(records, function(r){
            if (r.get('Feature')){
                features = Ext.Array.merge(features, [r.get('Feature').ObjectID]);
            }
        });
        return features.length;
    }
});


Ext.define('Rally.technicalservices.chart.FeatureSummary', {
    extend: 'Rally.ui.chart.Chart',
    alias: 'widget.tsfeaturesummary',

    config: {

        loadMask: false,

        chartConfig: {
            colors: [
                Rally.technicalservices.Color.featureDeployedColor,
                Rally.technicalservices.Color.featureNonDeployedColor
            ],

            chart: {
                plotBackgroundColor: null,
                plotBorderWidth: 0,
                plotShadow: false,
                type: 'bar'
            },
            title: {
                text: null
            },
            xAxis: {
                type: 'category',
                labels: {
                    enabled: true
                }
            },
            yAxis: {
                title: {
                    text: 'Feature Count'
                }
            },
            legend: {
                layout: 'vertical',
                align: 'right',
                verticalAlign: 'bottom',
                floating: true,
                y: -30
            },
            tooltip: {
                formatter: function () {

                    return this.series.name + ': ' + this.y + '<br/>' +
                        'Total: ' + this.point.stackTotal;
                }
            },
            plotOptions: {
                series: {
                    point: {
                        events: {
                            click: function(){
                                var data = Ext.create('Rally.technicalservices.DataPopover',{
                                    modelName: this.series.chart.userOptions.chart.modelName,
                                    fetch: this.series.chart.userOptions.chart.fetch,
                                    title: Ext.String.format("{0} {1} Features ({2} items)", this.category, this.series.name, this.oids.length || 0),
                                    oids: this.oids,
                                    width: Rally.getApp().getWidth(),
                                    maxHeight: Rally.getApp().getHeight()
                                });
                                data.show();
                            }
                        }
                    },
                    borderWidth: 0,
                    stacking: "normal"
                }
            }
        },
        chartData: {
            series: []
        }

    },
    constructor: function(config) {
        this.mergeConfig(config);

        this.chartData.series = this._getSeries(config.featureSummaryCalculator);
        this.callParent([this.config]);

    },
    initComponent: function() {
        this.callParent(arguments);
    },

    _getSeries: function(calculator){

        var categories = ['Total','Planned','Added','Descoped','Delivered'],
            deployable_data = [0,0,0,0,0],
            non_deployable_data = [0,0,0,0,0],
            model = calculator.featureModelName,
            serverFilters = [];

        if (calculator.deployableFeatures && calculator.deployableFeatures.length > 0){
            deployable_data = [
                {y: _.intersection(calculator.featuresCurrentOrOnLastDayOfRelease || [], calculator.deployableFeatures).length, oids: _.intersection(calculator.featuresCurrentOrOnLastDayOfRelease || [], calculator.deployableFeatures)},
                {y: _.intersection(calculator.featuresOnDay0 || [], calculator.deployableFeatures).length,oids: _.intersection(calculator.featuresOnDay0 || [], calculator.deployableFeatures)},
                {y: _.intersection(calculator.featuresAdded || [], calculator.deployableFeatures).length, oids: _.intersection(calculator.featuresAdded || [], calculator.deployableFeatures)},
                {y: _.intersection(calculator.featuresDescoped || [], calculator.deployableFeatures).length, oids: _.intersection(calculator.featuresDescoped || [], calculator.deployableFeatures)},
                {y: _.intersection(calculator.featuresCompleted || [], calculator.deployableFeatures).length, oids: _.intersection(calculator.featuresCompleted || [], calculator.deployableFeatures)}
            ];
        }

        if (calculator.nonDeployableFeatures && calculator.nonDeployableFeatures.length > 0){
            non_deployable_data = [
                {y: _.intersection(calculator.featuresCurrentOrOnLastDayOfRelease || [], calculator.nonDeployableFeatures).length, oids: _.intersection(calculator.featuresCurrentOrOnLastDayOfRelease || [], calculator.nonDeployableFeatures)},
                {y: _.intersection(calculator.featuresOnDay0 || [], calculator.nonDeployableFeatures).length, oids:_.intersection(calculator.featuresOnDay0 || [], calculator.nonDeployableFeatures)},
                {y: _.intersection(calculator.featuresAdded || [], calculator.nonDeployableFeatures).length, oids: _.intersection(calculator.featuresAdded || [], calculator.nonDeployableFeatures)},
                {y: _.intersection(calculator.featuresDescoped || [], calculator.nonDeployableFeatures).length, oids:_.intersection(calculator.featuresDescoped || [], calculator.nonDeployableFeatures)},
                {y: _.intersection(calculator.featuresCompleted || [], calculator.nonDeployableFeatures).length, oids: _.intersection(calculator.featuresCompleted || [], calculator.nonDeployableFeatures)}
            ];
        }
        this.chartData.categories = categories;
        this.chartConfig.chart.modelName = calculator.featureModelName;
        this.chartConfig.chart.fetch = ["FormattedID","Name","Project","State"];

        var series =  [{
                name: 'Deployable',
                data: deployable_data,
            }, {
                name: 'Non-Deployable',
                data: non_deployable_data
        }];

        return series;
    },

    _setChartColorsOnSeries: function () {
        return null;
    }
});


Ext.define("feature-summary", {
    extend: 'Rally.app.TimeboxScopedApp',
    scopeType: 'release',
    supportsUnscheduled: false,
    autoScroll: false,
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },

    completedStates: ["Operate","Done"],
    featureModelName: "PortfolioItem/Feature",

    onScopeChange: function(timeboxScope){

        if (this.down('#display_box')){
            this.down('#display_box').destroy();
        }
        this.add({
            xtype: 'container',
            itemId: 'display_box',
            width: '100%',
            layout:'vbox'
        });

        this.setLoading(true);
        Rally.technicalservices.WsapiToolbox.fetchReleases(timeboxScope).then({
            scope: this,
            success: function(releases){
                this.releases = releases;

                var calculator = Ext.create('Rally.technicalservices.calculator.FeatureSummary',{
                    timeboxScope: this.getContext().getTimeboxScope(),
                    context: this.getContext(),
                    releases: releases,
                    plannedDate: timeboxScope.getRecord().get('ReleaseStartDate'),
                    featureModelName: this.featureModelName,
                    completedStates: this.completedStates
                });
                calculator.calculate().then({
                    scope: this,
                    success: function(){
                        this.setLoading(false);
                        this.calculator = calculator;


                        this.down('#display_box').add({
                            xtype: 'rallybutton',
                            text: 'Team View',
                            cls: 'secondary rly-small',
                            listeners: {
                                scope: this,
                                click: this._updateView
                            }
                        });
                        this._showSummaryView(calculator);

                    }
                });
            },
            failure: function(msg){
                Rally.ui.notify.Notifier.showError({message: msg});
            }
        });

    },
    _updateView: function(btn){
        if (btn.text == 'Team View'){
            btn.setText("< Back to Summary");
            this._showTeamView(this.calculator);
        } else {
            btn.setText("Team View");
            this._showSummaryView(this.calculator);
        }
    },
    _showTeamView: function(calculator){
        var chart_width = this.getWidth();
        this.logger.log('width', chart_width);
        if (this.down('tsfeaturesummarybyteam')){
            this.down('tsfeaturesummarybyteam').destroy();
        }
        if (this.down('tsfeaturesummary')){
            this.down('tsfeaturesummary').destroy();
        }
        var summary = this.down('#display_box').add({
            xtype: 'tsfeaturesummarybyteam',
            padding: 15,
            featureSummaryCalculator: calculator
        });
        summary.setWidth(chart_width *.95);
        summary.setHeight(300);
    },
    _showSummaryView: function(calculator){
        var chart_width = this.getWidth();
        this.logger.log('width', chart_width);
        if (this.down('tsfeaturesummary')){
            this.down('tsfeaturesummary').destroy();
        }
        if (this.down('tsfeaturesummarybyteam')){
            this.down('tsfeaturesummarybyteam').destroy();
        }
        var summary = this.down('#display_box').add({
            xtype: 'tsfeaturesummary',
            padding: 15,
            featureSummaryCalculator: calculator
        });
        summary.setWidth(chart_width *.95);
        summary.setHeight(300);
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        Ext.apply(this, settings);
        this.launch();
    }
});

            
               Rally.launchApp('feature-summary', {
                   name: 'Feature Summary'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
    </style>

</head>
<body></body>
</html>